{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"What is KEML? KEML is a lightweight flexible alternative to HTMX , built around the concept of actions. The ideas that HTMX has recently made popular are, frankly, the best that the web community collectively has ever had. However, like most great ideas, they are far more important than any actual specific implementation. Despite offering a multitude of conveniences over HTMX and much greater flexibility, KEML still manages to be absolutely tiny in comparison. KEML v3 is ~4.5k minified and not gzipped and HTMX v2 is ~49.2k minified and not gzipped (~10.9x smaller). Motivation Being small and fast and configuration/plugin free is not enough, when you are trying to compete with a well established and popular library. So, why does KEML need to exist? KEML was born out of the classic 1-to-1 problem of the traditional jQuery-esque web application, that the HTMX api does nothing to address. Consider the following \"idiomatic\" HTMX code: <button hx-post=\"/clicked\" hx-trigger=\"click\" hx-target=\"#result\" hx-swap=\"innerHTML\" > Click Me! </button> <div id=\"result\"></div> Here the button element: can only react to exactly 1 event (\"click\") can only do 1 thing when that event happens (send a request to \"/clicked\") cannot delegate the request-sending to some other element/-s can only render the result into 1 (usually) target element has to know where that element is on the page, what its \"id\" and/or \"class\" attributes are has to decide for the target element the exact \"hx-swap\", of which there can only be 1 Out of these limitations arise: the need for a custom selector syntax built on top of the normal css-selector syntax the need for selectors in the first place, which you need to learn and understand to use the library effectively the implicit special handling of certain elements, like title and meta, present in the server response out of band swaps response selectors \"hx-preserve\" etc, etc, etc... All which, are meant to solve real tangible application needs, but in the process of doing that over-complicate things that do not need to be complicated. How is KEML different? Consider the following KEML code, that works with the same backend: <html> <head> <title render=\"result\"></title> </head> <body> <button on:click=\"handleClick doSomethingElse\" on:dblclick=\"handleDoubleClick\" > Click Me! </button> <button on:click=\"handleClick\">Click Me, maybe?!</button> <input on=\"handleClick\" post=\"/clicked\" type=\"text\" name=\"input1\" result=\"result\" > <input on=\"handleClick\" put=\"/notification\" type=\"text\" name=\"input2\" > <div render=\"result\" position=\"replaceWith\" ></div> <p render=\"result\" position=\"append\" ></p> </body> </html> both buttons initiate the same \"handleClick\" action on \"click\" the first button actually initiates two independent actions on \"click\", that could both do completely different things the first button also reacts to the double click event neither of the buttons needs to know how those actions are being handled, if at all the two text inputs both handle the \"handleClick\" action, but send completely different requests the first input gives the server response a render-able name \"result\" neither of the inputs knows anything about the rendering, whether or not anything is even going to be rendered at all, where and how the div, p and title elements render the same server response differently the div will be completely replaced with the response the p will append the response after its last child the title will replace all of its children with the response there is nothing special about the title element at all there's no need for ids, classes or selectors and the location of each element in the document is completely unimportant None of the problems that HTMX tries to solve with the complications listed above even exist in this paradigm! Is KEML feature-complete? While nothing is ever truly complete, the current feature-set should be able to cover 99% of actually useful HTMX features. I'm not going to claim that it is completely bug free and supports every browser under the sun, because it still has a long way to go until that becomes a reality. Thus, all constructive feedback and criticism are very welcome! If a feature of HTMX is missing, that means one of the following: it is made unnecessary by a more flexible API it is downright evil and/or going against the spirit of HATEOAS (e.g JSON endpoints, local templates and most forms of local state) it wasn't implemented yet","title":"Home"},{"location":"#what-is-keml","text":"KEML is a lightweight flexible alternative to HTMX , built around the concept of actions. The ideas that HTMX has recently made popular are, frankly, the best that the web community collectively has ever had. However, like most great ideas, they are far more important than any actual specific implementation. Despite offering a multitude of conveniences over HTMX and much greater flexibility, KEML still manages to be absolutely tiny in comparison. KEML v3 is ~4.5k minified and not gzipped and HTMX v2 is ~49.2k minified and not gzipped (~10.9x smaller).","title":"What is KEML?"},{"location":"#motivation","text":"Being small and fast and configuration/plugin free is not enough, when you are trying to compete with a well established and popular library.","title":"Motivation"},{"location":"#so-why-does-keml-need-to-exist","text":"KEML was born out of the classic 1-to-1 problem of the traditional jQuery-esque web application, that the HTMX api does nothing to address. Consider the following \"idiomatic\" HTMX code: <button hx-post=\"/clicked\" hx-trigger=\"click\" hx-target=\"#result\" hx-swap=\"innerHTML\" > Click Me! </button> <div id=\"result\"></div> Here the button element: can only react to exactly 1 event (\"click\") can only do 1 thing when that event happens (send a request to \"/clicked\") cannot delegate the request-sending to some other element/-s can only render the result into 1 (usually) target element has to know where that element is on the page, what its \"id\" and/or \"class\" attributes are has to decide for the target element the exact \"hx-swap\", of which there can only be 1 Out of these limitations arise: the need for a custom selector syntax built on top of the normal css-selector syntax the need for selectors in the first place, which you need to learn and understand to use the library effectively the implicit special handling of certain elements, like title and meta, present in the server response out of band swaps response selectors \"hx-preserve\" etc, etc, etc... All which, are meant to solve real tangible application needs, but in the process of doing that over-complicate things that do not need to be complicated.","title":"So, why does KEML need to exist?"},{"location":"#how-is-keml-different","text":"Consider the following KEML code, that works with the same backend: <html> <head> <title render=\"result\"></title> </head> <body> <button on:click=\"handleClick doSomethingElse\" on:dblclick=\"handleDoubleClick\" > Click Me! </button> <button on:click=\"handleClick\">Click Me, maybe?!</button> <input on=\"handleClick\" post=\"/clicked\" type=\"text\" name=\"input1\" result=\"result\" > <input on=\"handleClick\" put=\"/notification\" type=\"text\" name=\"input2\" > <div render=\"result\" position=\"replaceWith\" ></div> <p render=\"result\" position=\"append\" ></p> </body> </html> both buttons initiate the same \"handleClick\" action on \"click\" the first button actually initiates two independent actions on \"click\", that could both do completely different things the first button also reacts to the double click event neither of the buttons needs to know how those actions are being handled, if at all the two text inputs both handle the \"handleClick\" action, but send completely different requests the first input gives the server response a render-able name \"result\" neither of the inputs knows anything about the rendering, whether or not anything is even going to be rendered at all, where and how the div, p and title elements render the same server response differently the div will be completely replaced with the response the p will append the response after its last child the title will replace all of its children with the response there is nothing special about the title element at all there's no need for ids, classes or selectors and the location of each element in the document is completely unimportant None of the problems that HTMX tries to solve with the complications listed above even exist in this paradigm!","title":"How is KEML different?"},{"location":"#is-keml-feature-complete","text":"While nothing is ever truly complete, the current feature-set should be able to cover 99% of actually useful HTMX features. I'm not going to claim that it is completely bug free and supports every browser under the sun, because it still has a long way to go until that becomes a reality. Thus, all constructive feedback and criticism are very welcome! If a feature of HTMX is missing, that means one of the following: it is made unnecessary by a more flexible API it is downright evil and/or going against the spirit of HATEOAS (e.g JSON endpoints, local templates and most forms of local state) it wasn't implemented yet","title":"Is KEML feature-complete?"},{"location":"action/","text":"Handling actions HTML elements can trigger server requests and redirects in response to an action. More than one element can handle the same action and can trigger different requests. Relative endpoints are supported, so given a current URL of \"https:/ /www .example. com/some/path\": \"list-todo\" or \"./list-todo\" will both resolve to \"https:/ /www .example. com/some/path/list-todo/\" \"../list-todo\" will resolve to \"https:/ /www .example. com/some/list-todo/\" \"/list-todo\" will resolve to \"https:/ /www .example. com/list-todo/\" \"/file.html\" will resolve to \"https:/ /www .example. com/file.html\" (a trailing slash is always present for paths not ending with a file extension, and is never present for ones that are) Forms and form fields values are automatically serialized and sent to the server. What's more is that ANY element that sends a request can also be made serializable by giving it the \"name\" and the \"value\" attributes. A request is only allowed if an element is considered valid (i.e. it either does not have a checkValidity method or it returns true). KEML makes the server aware of the AJAX nature of its requests by automatically including a special \"X-Requested-With\" header in each request. KEML makes the server aware of the browsers timezone for the server-side date formatting by setting a \"tzo\" cookie to the value produced by the getTimezoneOffset function. Attributes on subscribes the element to a single action, initiated by any element, including the current one reset also subscribes the element to a single action, initiated by any element, including the current one, but is used specifically for resetting the current element (like a form or a form field, but really any element that has a reset method with the following signature: () => void ); resets are immediate and are not affected by debounce and throttle redirect if specified on an element with an on attribute makes it issue redirects instead of requests; redirect URIs are resolved exactly the same way as the request URIs; can have one of four possible values: pushState will call the same method of the history api replaceState will call the same method of the history api assign the same as pushState , but will cause a full page reload replace the same as replaceState , but will cause a full page reload href , action , src , get , post , put or delete are used to specify an endpoint to call (the default endpoint is \"\") method , get , post , put or delete are used to specify the HTTP method to use in the request (the default method is \"GET\") name and value can be used on any element, not just on form fields debounce specifies a number of milliseconds by which to debounce a request/redirect throttle specifies a number of milliseconds by which to throttle a request/redirect any attribute that starts with h- and contains a custom request header value credentials with any value or none at all, sets the XMLHttpRequest.withCredentials value to true once with any value or none at all, automatically removes the on attribute before starting a request/redirect Request Example clicking the button initiates the doSomething action the div subscribes to that action and sends a \"GET\" request to \"/data\" the checkbox subscribes to that action and sends a \"POST\" request to \"/toggle\" with a multipart encoded body containing its value nothing else happens since neither of the elements specifies what to do with their respective server responses <button on:click=\"doSomething\">click me</button> <div on=\"doSomething\" get=\"/data\" ></div> <input on=\"doSomething\" post=\"/toggle\" type=\"checkbox\" name=\"agree\" > Redirect Example this is exactly like the example above, but, because of the redirect attribute, instead of sending a network request we perform a redirect using the history api; in this case specifying an http method does nothing as it is meaningless in a redirect <button on:click=\"doSomething\">click me</button> <div on=\"doSomething\" redirect=\"pushState\" get=\"/data\" ></div> Reset Example clicking the button resets the form <button on:click=\"resetForm\">click me</button> <form reset=\"resetForm\"></form>","title":"Action"},{"location":"action/#handling-actions","text":"HTML elements can trigger server requests and redirects in response to an action. More than one element can handle the same action and can trigger different requests. Relative endpoints are supported, so given a current URL of \"https:/ /www .example. com/some/path\": \"list-todo\" or \"./list-todo\" will both resolve to \"https:/ /www .example. com/some/path/list-todo/\" \"../list-todo\" will resolve to \"https:/ /www .example. com/some/list-todo/\" \"/list-todo\" will resolve to \"https:/ /www .example. com/list-todo/\" \"/file.html\" will resolve to \"https:/ /www .example. com/file.html\" (a trailing slash is always present for paths not ending with a file extension, and is never present for ones that are) Forms and form fields values are automatically serialized and sent to the server. What's more is that ANY element that sends a request can also be made serializable by giving it the \"name\" and the \"value\" attributes. A request is only allowed if an element is considered valid (i.e. it either does not have a checkValidity method or it returns true). KEML makes the server aware of the AJAX nature of its requests by automatically including a special \"X-Requested-With\" header in each request. KEML makes the server aware of the browsers timezone for the server-side date formatting by setting a \"tzo\" cookie to the value produced by the getTimezoneOffset function.","title":"Handling actions"},{"location":"action/#attributes","text":"on subscribes the element to a single action, initiated by any element, including the current one reset also subscribes the element to a single action, initiated by any element, including the current one, but is used specifically for resetting the current element (like a form or a form field, but really any element that has a reset method with the following signature: () => void ); resets are immediate and are not affected by debounce and throttle redirect if specified on an element with an on attribute makes it issue redirects instead of requests; redirect URIs are resolved exactly the same way as the request URIs; can have one of four possible values: pushState will call the same method of the history api replaceState will call the same method of the history api assign the same as pushState , but will cause a full page reload replace the same as replaceState , but will cause a full page reload href , action , src , get , post , put or delete are used to specify an endpoint to call (the default endpoint is \"\") method , get , post , put or delete are used to specify the HTTP method to use in the request (the default method is \"GET\") name and value can be used on any element, not just on form fields debounce specifies a number of milliseconds by which to debounce a request/redirect throttle specifies a number of milliseconds by which to throttle a request/redirect any attribute that starts with h- and contains a custom request header value credentials with any value or none at all, sets the XMLHttpRequest.withCredentials value to true once with any value or none at all, automatically removes the on attribute before starting a request/redirect","title":"Attributes"},{"location":"action/#request-example","text":"clicking the button initiates the doSomething action the div subscribes to that action and sends a \"GET\" request to \"/data\" the checkbox subscribes to that action and sends a \"POST\" request to \"/toggle\" with a multipart encoded body containing its value nothing else happens since neither of the elements specifies what to do with their respective server responses <button on:click=\"doSomething\">click me</button> <div on=\"doSomething\" get=\"/data\" ></div> <input on=\"doSomething\" post=\"/toggle\" type=\"checkbox\" name=\"agree\" >","title":"Request Example"},{"location":"action/#redirect-example","text":"this is exactly like the example above, but, because of the redirect attribute, instead of sending a network request we perform a redirect using the history api; in this case specifying an http method does nothing as it is meaningless in a redirect <button on:click=\"doSomething\">click me</button> <div on=\"doSomething\" redirect=\"pushState\" get=\"/data\" ></div>","title":"Redirect Example"},{"location":"action/#reset-example","text":"clicking the button resets the form <button on:click=\"resetForm\">click me</button> <form reset=\"resetForm\"></form>","title":"Reset Example"},{"location":"event/","text":"Initiating actions HTML elements can trigger any number of application actions in response to any number of events. Furthermore, more than one element is allowed to initiate the same action. An action notifies the application of \"something\" happening, but in itself does nothing at all. All event types supported by the document object can be used, plus the following: reveal - triggered when an element becomes visible in the viewport, on initial page load or after a scroll conceal - triggered when an element leaves the viewport after a scroll navigate - triggered by the history api result - triggered after a successful request and render of a response (you can already rely on new attributes being present and working when this event is triggered) Attributes any attribute that starts with on: and contains a space separated list of actions to initiate any attribute that starts with event: and contains a comma separated list of name and value pairs separated by = ; the value part is optional and will default to true if omitted; every key and value pair has to match the event object, otherwise the event handling is skipped; can be used for associating hotkeys with an element, for example Example moving the mouse cursor into the button initiates the doSomething action clicking the button initiates two actions: loadData and updateCounter putting the cursor inside of the input and pressing Alt+Esc initiates the hotkeysAreCool action nothing happens as a result, since none of the elements subscribe to any of these actions <button on:mouseenter=\"doSomething\" on:click=\"loadData updateCounter\" > click me </button> <input on:keyup=\"hotkeysAreCool\" event:keyup=\"code=Escape, altKey\" > Please be mindful that all actions are, by design, global for a page that they are used on. It is your responsibility to generate unique action names if you want to be certain that no other parts of the application will be affected by the actions that you trigger. Example of a potential pitfall: <button on:click=\"loadData\" on=\"loadData\" get=\"/data.html\" > click me </button> <button on:click=\"loadData\" on=\"loadData\" get=\"/data.html\" > click me </button> In the example above we can imagine that it was the same button component, simply rendered twice. But, they are two distinct elements on the page that trigger and subscribe to the same action loadData . Thus, when you click either one of them, 2 (!) network requests will be sent to the server.","title":"Event"},{"location":"event/#initiating-actions","text":"HTML elements can trigger any number of application actions in response to any number of events. Furthermore, more than one element is allowed to initiate the same action. An action notifies the application of \"something\" happening, but in itself does nothing at all. All event types supported by the document object can be used, plus the following: reveal - triggered when an element becomes visible in the viewport, on initial page load or after a scroll conceal - triggered when an element leaves the viewport after a scroll navigate - triggered by the history api result - triggered after a successful request and render of a response (you can already rely on new attributes being present and working when this event is triggered)","title":"Initiating actions"},{"location":"event/#attributes","text":"any attribute that starts with on: and contains a space separated list of actions to initiate any attribute that starts with event: and contains a comma separated list of name and value pairs separated by = ; the value part is optional and will default to true if omitted; every key and value pair has to match the event object, otherwise the event handling is skipped; can be used for associating hotkeys with an element, for example","title":"Attributes"},{"location":"event/#example","text":"moving the mouse cursor into the button initiates the doSomething action clicking the button initiates two actions: loadData and updateCounter putting the cursor inside of the input and pressing Alt+Esc initiates the hotkeysAreCool action nothing happens as a result, since none of the elements subscribe to any of these actions <button on:mouseenter=\"doSomething\" on:click=\"loadData updateCounter\" > click me </button> <input on:keyup=\"hotkeysAreCool\" event:keyup=\"code=Escape, altKey\" > Please be mindful that all actions are, by design, global for a page that they are used on. It is your responsibility to generate unique action names if you want to be certain that no other parts of the application will be affected by the actions that you trigger. Example of a potential pitfall: <button on:click=\"loadData\" on=\"loadData\" get=\"/data.html\" > click me </button> <button on:click=\"loadData\" on=\"loadData\" get=\"/data.html\" > click me </button> In the example above we can imagine that it was the same button component, simply rendered twice. But, they are two distinct elements on the page that trigger and subscribe to the same action loadData . Thus, when you click either one of them, 2 (!) network requests will be sent to the server.","title":"Example"},{"location":"glossary/","text":"Attribute Glossary Name Applied With Description on:<event name> * initiate event actions event:<event name> on:<event name> cancel the event handling if the event object does not match the specified shape on * subscribe to an action to perform a network request or a redirect debounce on debounce network requests and redirects throttle on throttle network requests and redirects get , href , action or src on specify a server endpoint for a GET request post on specify a server endpoint for a POST request put on specify a server endpoint for a PUT request delete on specify a server endpoint for a DELETE request method on specify an http method, overriding any otherwise inferred name + value on make any element serializable for the server request credentials on set the XMLHttpRequest.withCredentials flag to true for this request h-<header name> on specify any additional request headers result on initiate render actions after a successful response error on initiate render actions after an unsuccessful response redirect on disregard any request configuration except for the URL resolution and do a redirect instead once on automatically remove the on attribute right before sending a request/redirect for the first time if:loading on initiate loading state actions right before starting a request if:error on initiate error state actions after an unsuccessful server response render * render a server response identified by a specific render action position render specify where to place the server response in relation to the current element if:invalid * initiate invalid state actions if an elements' value becomes invalid if:value * initiate value state actions when the elements' value is not empty if:intersects * initiate intersects state actions when the element intersects the viewport if * react to a single state action x-<attribute name> if turn an \"x-\" attribute into an ordinary attribute when a state action activates","title":"Glossary"},{"location":"glossary/#attribute-glossary","text":"Name Applied With Description on:<event name> * initiate event actions event:<event name> on:<event name> cancel the event handling if the event object does not match the specified shape on * subscribe to an action to perform a network request or a redirect debounce on debounce network requests and redirects throttle on throttle network requests and redirects get , href , action or src on specify a server endpoint for a GET request post on specify a server endpoint for a POST request put on specify a server endpoint for a PUT request delete on specify a server endpoint for a DELETE request method on specify an http method, overriding any otherwise inferred name + value on make any element serializable for the server request credentials on set the XMLHttpRequest.withCredentials flag to true for this request h-<header name> on specify any additional request headers result on initiate render actions after a successful response error on initiate render actions after an unsuccessful response redirect on disregard any request configuration except for the URL resolution and do a redirect instead once on automatically remove the on attribute right before sending a request/redirect for the first time if:loading on initiate loading state actions right before starting a request if:error on initiate error state actions after an unsuccessful server response render * render a server response identified by a specific render action position render specify where to place the server response in relation to the current element if:invalid * initiate invalid state actions if an elements' value becomes invalid if:value * initiate value state actions when the elements' value is not empty if:intersects * initiate intersects state actions when the element intersects the viewport if * react to a single state action x-<attribute name> if turn an \"x-\" attribute into an ordinary attribute when a state action activates","title":"Attribute Glossary"},{"location":"install/","text":"Installation There is no programmatic API, nothing is exported in JS, nothing to install or configure. You load the library from a CDN and forget that JS even existed at all. <script src=\"https://unpkg.com/keml\"></script> Using with other libraries and frameworks There's also nothing special that you need to do here. KEML automatically observes all changes to the DOM. That means that your custom code can simply create elements and update their attributes at any point, and they will continue to work with KEML exactly the same as if they were rendered on the server.","title":"Install"},{"location":"install/#installation","text":"There is no programmatic API, nothing is exported in JS, nothing to install or configure. You load the library from a CDN and forget that JS even existed at all. <script src=\"https://unpkg.com/keml\"></script>","title":"Installation"},{"location":"install/#using-with-other-libraries-and-frameworks","text":"There's also nothing special that you need to do here. KEML automatically observes all changes to the DOM. That means that your custom code can simply create elements and update their attributes at any point, and they will continue to work with KEML exactly the same as if they were rendered on the server.","title":"Using with other libraries and frameworks"},{"location":"news/","text":"News v3 is finally out! It is said that simplicity is hard and absolute simplicity is hard absolutely. KEML v3 was that and much more. And, while a major version of a library could simply be prompted by any breaking change, what we have here is certainly not that case. It was probably more like v123, or something like that, behind the scenes with the sheer number of complete rewrites, head scratching, and a couple of moments of brilliance. v3 brings new features, stability, reliability, resilience, performance, memory efficiency and optimizations that were nigh impossible with v2. And it does it all while having an even smaller file size. So, what changed? No Magic Magic, in programming, can be described as - behaviors determined by nothing other than naming something a certain way or placing it in a certain place. And it is almost always a really bad idea. The so called \"special actions\" were a major pain in the rear end that came out of technical limitations and nothing else. v3 embraces actions to the max, literally everything is controlled by them and nothing else and there are no special and/or reserved action names at all. Observing the DOM DOM changes are automatically observed in v3. Whether an element came from the server on the initial page load, after subsequent AJAX requests, is created or modified by userland code, by you changing something through the dev tools DOM Inspector tab, or even by some browser extension, it makes no difference at all. That's right, KEML will never be broken by another password manager ever again :) And if you want to use jQuery or React alongside KEML, you totally can. And you never need to tell it that you've changed something in the document. New Features v3 comes with a couple of new states, a couple of new ways to perform a redirect and somewhat of a way to handle hotkeys, but really, nothing Earth-shattering. The big deal is that the greatly improved codebase allows adding new features easily and without breaking the existing ones or negatively affecting the performance. Breaking Changes The only breaking change is the absence of \"special\" actions. So, this: <a on:click=\"pushState\" href=\"/something\" ></a> Has to turn into this (the same with replaceState ): <a on:click=\"someUniqueName\" on=\"someUniqueName\" redirect=\"pushState\" href=\"/something\" ></a> The redirect attribute cannot contain an endpoint configuration anymore. And this: <form on:submit=\"doSubmit reset\"></form> Has to turn into this: <form on:submit=\"doSubmit resetThisForm\" reset=\"resetThisForm\" ></form> It looks more verbose, but offers infinitely more flexibility. That's all, folks! Happy coding and have an awesome day, Eugene K.","title":"News"},{"location":"news/#news","text":"","title":"News"},{"location":"news/#v3-is-finally-out","text":"It is said that simplicity is hard and absolute simplicity is hard absolutely. KEML v3 was that and much more. And, while a major version of a library could simply be prompted by any breaking change, what we have here is certainly not that case. It was probably more like v123, or something like that, behind the scenes with the sheer number of complete rewrites, head scratching, and a couple of moments of brilliance. v3 brings new features, stability, reliability, resilience, performance, memory efficiency and optimizations that were nigh impossible with v2. And it does it all while having an even smaller file size.","title":"v3 is finally out!"},{"location":"news/#so-what-changed","text":"","title":"So, what changed?"},{"location":"news/#no-magic","text":"Magic, in programming, can be described as - behaviors determined by nothing other than naming something a certain way or placing it in a certain place. And it is almost always a really bad idea. The so called \"special actions\" were a major pain in the rear end that came out of technical limitations and nothing else. v3 embraces actions to the max, literally everything is controlled by them and nothing else and there are no special and/or reserved action names at all.","title":"No Magic"},{"location":"news/#observing-the-dom","text":"DOM changes are automatically observed in v3. Whether an element came from the server on the initial page load, after subsequent AJAX requests, is created or modified by userland code, by you changing something through the dev tools DOM Inspector tab, or even by some browser extension, it makes no difference at all. That's right, KEML will never be broken by another password manager ever again :) And if you want to use jQuery or React alongside KEML, you totally can. And you never need to tell it that you've changed something in the document.","title":"Observing the DOM"},{"location":"news/#new-features","text":"v3 comes with a couple of new states, a couple of new ways to perform a redirect and somewhat of a way to handle hotkeys, but really, nothing Earth-shattering. The big deal is that the greatly improved codebase allows adding new features easily and without breaking the existing ones or negatively affecting the performance.","title":"New Features"},{"location":"news/#breaking-changes","text":"The only breaking change is the absence of \"special\" actions. So, this: <a on:click=\"pushState\" href=\"/something\" ></a> Has to turn into this (the same with replaceState ): <a on:click=\"someUniqueName\" on=\"someUniqueName\" redirect=\"pushState\" href=\"/something\" ></a> The redirect attribute cannot contain an endpoint configuration anymore. And this: <form on:submit=\"doSubmit reset\"></form> Has to turn into this: <form on:submit=\"doSubmit resetThisForm\" reset=\"resetThisForm\" ></form> It looks more verbose, but offers infinitely more flexibility. That's all, folks! Happy coding and have an awesome day, Eugene K.","title":"Breaking Changes"},{"location":"render/","text":"Rendering responses HTML elements that trigger requests can initiate multiple result actions after receiving a server response. Multiple elements can initiate the same result action, thus triggering the render of a different response under the same action name. Multiple elements can subscribe to the same result action and render the same server response. KEML applies the minimum set of DOM mutations necessary to synchronize the document with the server response. If the server response can be determined to be the same as what is currently rendered in the document, no changes are applied at all. Attributes result specified on an element that performs a request and contains a space separated list of render actions to initiate error works exactly like result but for situations when the server responds with an unsuccessful status code render specified on any element, including the same one that triggered the request and contains the render action name to subscribe to position controls the render strategy to apply to itself: replaceChildren (default) replaces all of the elements' children with the server response replaceWith replaces the element itself with the server response before renders the server response directly before the current element after renders the server response directly after the current element prepend prepends the server response before the first child of the current element append appends the server response after the last child of the current element Example clicking the button initiates the getUserCount action the button itself subscribes to that action using the on attribute the button sends a \"GET\" request to \"/user-count\" upon successfully receiving the response the button initiates the userCount result action the div subscribes to the userCount action and renders the server response into itself the span subscribes to the userCount action and replaces itself with the server response <button on:click=\"getUserCount\" on=\"getUserCount\" get=\"/user-count\" result=\"userCount\" > click me </button> <div render=\"userCount\"></div> <span render=\"userCount\" position=\"replaceWith\" ></span>","title":"Render"},{"location":"render/#rendering-responses","text":"HTML elements that trigger requests can initiate multiple result actions after receiving a server response. Multiple elements can initiate the same result action, thus triggering the render of a different response under the same action name. Multiple elements can subscribe to the same result action and render the same server response. KEML applies the minimum set of DOM mutations necessary to synchronize the document with the server response. If the server response can be determined to be the same as what is currently rendered in the document, no changes are applied at all.","title":"Rendering responses"},{"location":"render/#attributes","text":"result specified on an element that performs a request and contains a space separated list of render actions to initiate error works exactly like result but for situations when the server responds with an unsuccessful status code render specified on any element, including the same one that triggered the request and contains the render action name to subscribe to position controls the render strategy to apply to itself: replaceChildren (default) replaces all of the elements' children with the server response replaceWith replaces the element itself with the server response before renders the server response directly before the current element after renders the server response directly after the current element prepend prepends the server response before the first child of the current element append appends the server response after the last child of the current element","title":"Attributes"},{"location":"render/#example","text":"clicking the button initiates the getUserCount action the button itself subscribes to that action using the on attribute the button sends a \"GET\" request to \"/user-count\" upon successfully receiving the response the button initiates the userCount result action the div subscribes to the userCount action and renders the server response into itself the span subscribes to the userCount action and replaces itself with the server response <button on:click=\"getUserCount\" on=\"getUserCount\" get=\"/user-count\" result=\"userCount\" > click me </button> <div render=\"userCount\"></div> <span render=\"userCount\" position=\"replaceWith\" ></span>","title":"Example"},{"location":"state/","text":"State actions HTML elements can configure any number of attributes in response to state actions by prepending their names with x- . Multiple elements can handle the same action and configure their attributes differently. A state can essentially be viewed as a boolean flag that is always set to false by default. Attributes if:loading specified on an element that launches a request, contains a space separated list of state actions to turn ON immediately before starting a request and to turn OFF immediately after a request completes if:error specified on an element that launches a request, contains a space separated list of state actions to turn OFF immediately before starting a request and to turn ON immediately after a request fails if:invalid specified on a form or a form field, contains a space separated list of state actions to turn ON when the element becomes invalid and to turn OFF when the element becomes valid (invalid forms and fields do not trigger server requests) if:value inputs, selects, text areas and checkboxes can be considered to have a value when they are not empty if:intersects is turned ON when the element intersects the viewport if specified on any element, including the same one that issued a state action, and subscribes to a single state action Loading State Example the first div is initially visible and the second div is initially hidden clicking the button: initiates the loadData action turns ON the isLoadingData state action, thus the first div becomes invisible and the second visible sends a \"GET\" request to \"/data\" after completion of the request turns OFF the isLoadingData state action, thus the first div becomes visible and the second invisible again <button on:click=\"loadData\" on=\"loadData\" get=\"/data\" if:loading=\"isLoadingData\" > click me </button> <div if=\"isLoadingData\" x-style=\"display: none\" > not loading </div> <div if=\"isLoadingData\" style=\"display: none\" x-style > loading </div> Error State Example the first div is initially visible and the second div is initially hidden clicking the button initiates the loadWrong action turns OFF the isError state action, which does not change the visibility of the divs sends a \"GET\" request to \"/non-existent\" after completion of the request turns ON the isError state action, because the request has failed, thus the first div becomes invisible and the second visible <button on:click=\"loadWrong\" on=\"loadWrong\" get=\"/non-existent\" if:error=\"isError\" > click me </button> <div if=\"isError\" x-style=\"display: none\" > no error </div> <div if=\"isError\" style=\"display: none\" x-style > error </div> Invalid State Example the first div will be visible initially as well as when the inputs' value becomes a valid email the second div will be visible only when the inputs' value becomes an invalid email <input if:invalid=\"invalidEmail\" type=\"email\" > <div if=\"invalidEmail\" x-style=\"display: none\" > valid </div> <div if=\"invalidEmail\" style=\"display: none\" x-style > invalid </div> Value State Example the first div will be visible when the input value is cleared in some way the second div will be visible when the user enters something into the input <input if:value=\"isNotEmpty\" type=\"text\" > <div if=\"isNotEmpty\" x-style=\"display: none\" > empty </div> <div if=\"isNotEmpty\" style=\"display: none\" x-style > not empty </div> Intersects State Example the first div will be visible when the user scrolls the page such that the paragraph is out of view or if the paragraph is removed from the page altogether the second div will be visible when the paragraph becomes visible in the viewport <p if:intersects=\"canSee\"></p> <br> <br> <br> <div if=\"canSee\" x-style=\"display: none\" > out of viewport </div> <div if=\"canSee\" style=\"display: none\" x-style > in the viewport </div>","title":"State"},{"location":"state/#state-actions","text":"HTML elements can configure any number of attributes in response to state actions by prepending their names with x- . Multiple elements can handle the same action and configure their attributes differently. A state can essentially be viewed as a boolean flag that is always set to false by default.","title":"State actions"},{"location":"state/#attributes","text":"if:loading specified on an element that launches a request, contains a space separated list of state actions to turn ON immediately before starting a request and to turn OFF immediately after a request completes if:error specified on an element that launches a request, contains a space separated list of state actions to turn OFF immediately before starting a request and to turn ON immediately after a request fails if:invalid specified on a form or a form field, contains a space separated list of state actions to turn ON when the element becomes invalid and to turn OFF when the element becomes valid (invalid forms and fields do not trigger server requests) if:value inputs, selects, text areas and checkboxes can be considered to have a value when they are not empty if:intersects is turned ON when the element intersects the viewport if specified on any element, including the same one that issued a state action, and subscribes to a single state action","title":"Attributes"},{"location":"state/#loading-state-example","text":"the first div is initially visible and the second div is initially hidden clicking the button: initiates the loadData action turns ON the isLoadingData state action, thus the first div becomes invisible and the second visible sends a \"GET\" request to \"/data\" after completion of the request turns OFF the isLoadingData state action, thus the first div becomes visible and the second invisible again <button on:click=\"loadData\" on=\"loadData\" get=\"/data\" if:loading=\"isLoadingData\" > click me </button> <div if=\"isLoadingData\" x-style=\"display: none\" > not loading </div> <div if=\"isLoadingData\" style=\"display: none\" x-style > loading </div>","title":"Loading State Example"},{"location":"state/#error-state-example","text":"the first div is initially visible and the second div is initially hidden clicking the button initiates the loadWrong action turns OFF the isError state action, which does not change the visibility of the divs sends a \"GET\" request to \"/non-existent\" after completion of the request turns ON the isError state action, because the request has failed, thus the first div becomes invisible and the second visible <button on:click=\"loadWrong\" on=\"loadWrong\" get=\"/non-existent\" if:error=\"isError\" > click me </button> <div if=\"isError\" x-style=\"display: none\" > no error </div> <div if=\"isError\" style=\"display: none\" x-style > error </div>","title":"Error State Example"},{"location":"state/#invalid-state-example","text":"the first div will be visible initially as well as when the inputs' value becomes a valid email the second div will be visible only when the inputs' value becomes an invalid email <input if:invalid=\"invalidEmail\" type=\"email\" > <div if=\"invalidEmail\" x-style=\"display: none\" > valid </div> <div if=\"invalidEmail\" style=\"display: none\" x-style > invalid </div>","title":"Invalid State Example"},{"location":"state/#value-state-example","text":"the first div will be visible when the input value is cleared in some way the second div will be visible when the user enters something into the input <input if:value=\"isNotEmpty\" type=\"text\" > <div if=\"isNotEmpty\" x-style=\"display: none\" > empty </div> <div if=\"isNotEmpty\" style=\"display: none\" x-style > not empty </div>","title":"Value State Example"},{"location":"state/#intersects-state-example","text":"the first div will be visible when the user scrolls the page such that the paragraph is out of view or if the paragraph is removed from the page altogether the second div will be visible when the paragraph becomes visible in the viewport <p if:intersects=\"canSee\"></p> <br> <br> <br> <div if=\"canSee\" x-style=\"display: none\" > out of viewport </div> <div if=\"canSee\" style=\"display: none\" x-style > in the viewport </div>","title":"Intersects State Example"}]}