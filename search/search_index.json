{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"What is KEML? KEML is a lightweight flexible alternative to HTMX , built around the concept of actions. The ideas that HTMX has recently made popular are, frankly, the best that the web community collectively has ever had. However, like most great ideas, it is far more important than any actual specific implementation. Motivation Being small and fast and configuration/plugin free is not enough, when you are trying to compete with a well established and popular library. So, why does KEML need to exist? KEML was born out of the classic 1-to-1 problem of the traditional jQuery-esque web application, that the HTMX api does nothing to address. Consider the following \"idiomatic\" HTMX code: <button hx-post=\"/clicked\" hx-trigger=\"click\" hx-target=\"#result\" hx-swap=\"innerHTML\" > Click Me! </button> <div id=\"result\"></div> Here the button element: can only react to exactly 1 event (\"click\") can only do 1 thing when that event happens (send a request to \"/clicked\") cannot delegate the request-sending to some other element/-s can only render the result into 1 (usually) target element has to know where that element is in the page, what its \"id\" and/or \"class\" attributes are has to decide for the target element the exact \"hx-swap\", of which there can only be 1 Out of these limitations arise: the need for a custom selector syntax built on top of the normal css-selector syntax the need for selectors in the first place, which you need to learn and understand to use the library effectively the implicit special handling of certain elements, like title and meta, present in the server response out of band swaps response selectors \"hx-preserve\" etc, etc, etc... All which, are meant to solve real tangible application needs, but in the process of doing that over-complicate things that do not need to be complicated. How is KEML different? Consider the following KEML code, that works with the same backend: <html> <head> <title render=\"result\"></title> </head> <body> <button on:click=\"handleClick doSomethingElse\" on:dblclick=\"handleDoubleClick\" > Click Me! </button> <button on:click=\"handleClick\"> Click Me, maybe?! </button> <input on=\"handleClick\" post=\"/clicked\" type=\"text\" name=\"input1\" result=\"result\" > <input on=\"handleClick\" put=\"/notification\" type=\"text\" name=\"input2\" > <div render=\"result\" position=\"replaceWith\" ></div> <p render=\"result\" position=\"append\" ></p> </body> </html> both buttons initiate the same \"handleClick\" action on \"click\" the first button actually initiates two independent actions on \"click\", that could both do completely different things the first button also reacts to the double click event neither of the buttons needs to know how those actions are being handled, if at all the two text inputs both handle the \"handleClick\" action, but send completely different requests the first input gives the server response a render-able name \"result\" neither of the inputs knows anything about the rendering, whether or not anything is even going to be rendered at all, where and how the div, p and title elements render the same server response differently the div will be completely replaced with the response the p will append the response after its last child the title will replace all of its children with the response there is nothing special about the title element at all there's no need for ids, classes or selectors and the location of each element in the document is completely unimportant None of the problems that HTMX tries to solve with the complications listed above even exist in this paradigm! Is KEML feature-complete? While nothing is ever truly complete, the current feature-set should be able to cover 99% of actually useful HTMX features. I'm not going to claim that it is completely bug free and supports every browser under the sun, because it still has a long way to go until that becomes a reality. Thus, all constructive feedback and criticism are very welcome! If a feature of HTMX is missing, that means one of the following: it is made unnecessary by a more flexible API it is downright evil and/or going against the spirit of HATEOAS (e.g JSON endpoints, local templates and most forms of local state) it wasn't implemented yet","title":"Home"},{"location":"#what-is-keml","text":"KEML is a lightweight flexible alternative to HTMX , built around the concept of actions. The ideas that HTMX has recently made popular are, frankly, the best that the web community collectively has ever had. However, like most great ideas, it is far more important than any actual specific implementation.","title":"What is KEML?"},{"location":"#motivation","text":"Being small and fast and configuration/plugin free is not enough, when you are trying to compete with a well established and popular library.","title":"Motivation"},{"location":"#so-why-does-keml-need-to-exist","text":"KEML was born out of the classic 1-to-1 problem of the traditional jQuery-esque web application, that the HTMX api does nothing to address. Consider the following \"idiomatic\" HTMX code: <button hx-post=\"/clicked\" hx-trigger=\"click\" hx-target=\"#result\" hx-swap=\"innerHTML\" > Click Me! </button> <div id=\"result\"></div> Here the button element: can only react to exactly 1 event (\"click\") can only do 1 thing when that event happens (send a request to \"/clicked\") cannot delegate the request-sending to some other element/-s can only render the result into 1 (usually) target element has to know where that element is in the page, what its \"id\" and/or \"class\" attributes are has to decide for the target element the exact \"hx-swap\", of which there can only be 1 Out of these limitations arise: the need for a custom selector syntax built on top of the normal css-selector syntax the need for selectors in the first place, which you need to learn and understand to use the library effectively the implicit special handling of certain elements, like title and meta, present in the server response out of band swaps response selectors \"hx-preserve\" etc, etc, etc... All which, are meant to solve real tangible application needs, but in the process of doing that over-complicate things that do not need to be complicated.","title":"So, why does KEML need to exist?"},{"location":"#how-is-keml-different","text":"Consider the following KEML code, that works with the same backend: <html> <head> <title render=\"result\"></title> </head> <body> <button on:click=\"handleClick doSomethingElse\" on:dblclick=\"handleDoubleClick\" > Click Me! </button> <button on:click=\"handleClick\"> Click Me, maybe?! </button> <input on=\"handleClick\" post=\"/clicked\" type=\"text\" name=\"input1\" result=\"result\" > <input on=\"handleClick\" put=\"/notification\" type=\"text\" name=\"input2\" > <div render=\"result\" position=\"replaceWith\" ></div> <p render=\"result\" position=\"append\" ></p> </body> </html> both buttons initiate the same \"handleClick\" action on \"click\" the first button actually initiates two independent actions on \"click\", that could both do completely different things the first button also reacts to the double click event neither of the buttons needs to know how those actions are being handled, if at all the two text inputs both handle the \"handleClick\" action, but send completely different requests the first input gives the server response a render-able name \"result\" neither of the inputs knows anything about the rendering, whether or not anything is even going to be rendered at all, where and how the div, p and title elements render the same server response differently the div will be completely replaced with the response the p will append the response after its last child the title will replace all of its children with the response there is nothing special about the title element at all there's no need for ids, classes or selectors and the location of each element in the document is completely unimportant None of the problems that HTMX tries to solve with the complications listed above even exist in this paradigm!","title":"How is KEML different?"},{"location":"#is-keml-feature-complete","text":"While nothing is ever truly complete, the current feature-set should be able to cover 99% of actually useful HTMX features. I'm not going to claim that it is completely bug free and supports every browser under the sun, because it still has a long way to go until that becomes a reality. Thus, all constructive feedback and criticism are very welcome! If a feature of HTMX is missing, that means one of the following: it is made unnecessary by a more flexible API it is downright evil and/or going against the spirit of HATEOAS (e.g JSON endpoints, local templates and most forms of local state) it wasn't implemented yet","title":"Is KEML feature-complete?"},{"location":"event/","text":"Initiating actions HTML elements can trigger any number of application actions in response to any number of events. Furthermore, more than one element is allowed to initiate the same action. An action notifies the application of \"something\" happening, but in itself does nothing at all. All event types supported by the document object can be used, plus the following: reveal - triggered when an element becomes visible in the viewport, on initial page load or after a scroll conceal - triggered when an element leaves the viewport after a scroll navigate - triggered by the history api result - triggered after a successful request Attributes any attribute that starts with on: and contains a space separated list of actions to initiate Example moving the mouse cursor into the button initiates the doSomething action clicking the button initiates two actions: loadData and updateCounter nothing happens as a result, since none of the elements subscribe to either of these actions <button on:mouseenter=\"doSomething\" on:click=\"loadData updateCounter\" > click me </button>","title":"Event"},{"location":"event/#initiating-actions","text":"HTML elements can trigger any number of application actions in response to any number of events. Furthermore, more than one element is allowed to initiate the same action. An action notifies the application of \"something\" happening, but in itself does nothing at all. All event types supported by the document object can be used, plus the following: reveal - triggered when an element becomes visible in the viewport, on initial page load or after a scroll conceal - triggered when an element leaves the viewport after a scroll navigate - triggered by the history api result - triggered after a successful request","title":"Initiating actions"},{"location":"event/#attributes","text":"any attribute that starts with on: and contains a space separated list of actions to initiate","title":"Attributes"},{"location":"event/#example","text":"moving the mouse cursor into the button initiates the doSomething action clicking the button initiates two actions: loadData and updateCounter nothing happens as a result, since none of the elements subscribe to either of these actions <button on:mouseenter=\"doSomething\" on:click=\"loadData updateCounter\" > click me </button>","title":"Example"},{"location":"install/","text":"Installation There is no programmatic API, nothing is exported in JS, nothing to install or configure. You load the library from a CDN and forget that JS even existed at all. <script src=\"https://unpkg.com/keml\"></script>","title":"Install"},{"location":"install/#installation","text":"There is no programmatic API, nothing is exported in JS, nothing to install or configure. You load the library from a CDN and forget that JS even existed at all. <script src=\"https://unpkg.com/keml\"></script>","title":"Installation"},{"location":"render/","text":"Rendering responses HTML elements that trigger requests can initiate multiple result actions after receiving a server response. Multiple elements can initiate the same result action, thus triggering the render of a different response under the same action name. Multiple elements can subscribe to the same result action and render the same server response. Computes the minimum set of DOM mutations necessary to synchronize the document with the server response. If the server response can be determined to be the same as what is currently rendered in the document, no changes are applied at all. Attributes result specified on an element that performs a request and contains a space separated list of result actions to initiate error works exactly like result but for situations when the server responds with an unsuccessful status code render specified on any element, including the same one that triggered the request and contains the render action name to subscribe to position controls the render strategy to apply to itself: replaceChildren (default) replaces all of the elements' children with the server response replaceWith replaces the element itself with the server response before renders the server response directly before the current element after renders the server response directly after the current element prepend prepends the server response before the first child of the current element append appends the server response after the last child of the current element Example clicking the button initiates the getUserCount action the button itself subscribes to that action using the on attribute the button sends a \"GET\" request to \"/user-count\" upon successfully receiving the response the button initiates the userCount result action the div subscribes to the userCount action and renders the server response into itself the span subscribes to the userCount action and replaces itself with the server response <button on:click=\"getUserCount\" on=\"getUserCount\" get=\"/user-count\" result=\"userCount\" > click me </button> <div render=\"userCount\" ></div> <span render=\"userCount\" position=\"replaceWith\" ></span>","title":"Render"},{"location":"render/#rendering-responses","text":"HTML elements that trigger requests can initiate multiple result actions after receiving a server response. Multiple elements can initiate the same result action, thus triggering the render of a different response under the same action name. Multiple elements can subscribe to the same result action and render the same server response. Computes the minimum set of DOM mutations necessary to synchronize the document with the server response. If the server response can be determined to be the same as what is currently rendered in the document, no changes are applied at all.","title":"Rendering responses"},{"location":"render/#attributes","text":"result specified on an element that performs a request and contains a space separated list of result actions to initiate error works exactly like result but for situations when the server responds with an unsuccessful status code render specified on any element, including the same one that triggered the request and contains the render action name to subscribe to position controls the render strategy to apply to itself: replaceChildren (default) replaces all of the elements' children with the server response replaceWith replaces the element itself with the server response before renders the server response directly before the current element after renders the server response directly after the current element prepend prepends the server response before the first child of the current element append appends the server response after the last child of the current element","title":"Attributes"},{"location":"render/#example","text":"clicking the button initiates the getUserCount action the button itself subscribes to that action using the on attribute the button sends a \"GET\" request to \"/user-count\" upon successfully receiving the response the button initiates the userCount result action the div subscribes to the userCount action and renders the server response into itself the span subscribes to the userCount action and replaces itself with the server response <button on:click=\"getUserCount\" on=\"getUserCount\" get=\"/user-count\" result=\"userCount\" > click me </button> <div render=\"userCount\" ></div> <span render=\"userCount\" position=\"replaceWith\" ></span>","title":"Example"},{"location":"request/","text":"Sending requests HTML elements can trigger server requests in response to an action. More than one element can handle the same action and can trigger different requests. Relative endpoints are supported, so given a current URI of \"https:/ /www .example. com/some/path\": \"list-todo\" or \"./list-todo\" will both resolve to \"https:/ /www .example. com/some/path/list-todo\" \"../list-todo\" will resolve to \"https:/ /www .example. com/some/list-todo\" \"/list-todo\" will resolve to \"https:/ /www .example. com/list-todo\" Forms and form fields values are automatically serialized and sent to the server. What's more is that ANY element that sends a request can also be made serializable by giving it the \"name\" and the \"value\" attributes. Attributes on subscribes the element to a single action, initiated by any element, including the current one href , action , src , get , post , put or delete are used to specify an endpoint to call method , get , post , put or delete are used to specify the HTTP method to use in the request name and value can be used on any element, not just on form fields debounce specifies a number of milliseconds by which to debounce a request throttle specifies a number of milliseconds by which to throttle a request any attribute that starts with h- and contains a custom request header value credentials with any value or none at all, sets the XMLHttpRequest.withCredentials value to true once with any value or none at all, automatically removes the on attribute after a successful request Example clicking the button initiates the doSomething action the div subscribes to that action and sends a \"GET\" request to \"/data\" the checkbox subscribes to that action and sends a \"POST\" request to \"/toggle\" with a multipart encoded body containing its value nothing else happens since neither of the elements specifies what to do with their respective server responses <button on:click=\"doSomething\">click me</button> <div on=\"doSomething\" get=\"/data\" ></div> <input on=\"doSomething\" post=\"/toggle\" type=\"checkbox\" name=\"agree\" >","title":"Request"},{"location":"request/#sending-requests","text":"HTML elements can trigger server requests in response to an action. More than one element can handle the same action and can trigger different requests. Relative endpoints are supported, so given a current URI of \"https:/ /www .example. com/some/path\": \"list-todo\" or \"./list-todo\" will both resolve to \"https:/ /www .example. com/some/path/list-todo\" \"../list-todo\" will resolve to \"https:/ /www .example. com/some/list-todo\" \"/list-todo\" will resolve to \"https:/ /www .example. com/list-todo\" Forms and form fields values are automatically serialized and sent to the server. What's more is that ANY element that sends a request can also be made serializable by giving it the \"name\" and the \"value\" attributes.","title":"Sending requests"},{"location":"request/#attributes","text":"on subscribes the element to a single action, initiated by any element, including the current one href , action , src , get , post , put or delete are used to specify an endpoint to call method , get , post , put or delete are used to specify the HTTP method to use in the request name and value can be used on any element, not just on form fields debounce specifies a number of milliseconds by which to debounce a request throttle specifies a number of milliseconds by which to throttle a request any attribute that starts with h- and contains a custom request header value credentials with any value or none at all, sets the XMLHttpRequest.withCredentials value to true once with any value or none at all, automatically removes the on attribute after a successful request","title":"Attributes"},{"location":"request/#example","text":"clicking the button initiates the doSomething action the div subscribes to that action and sends a \"GET\" request to \"/data\" the checkbox subscribes to that action and sends a \"POST\" request to \"/toggle\" with a multipart encoded body containing its value nothing else happens since neither of the elements specifies what to do with their respective server responses <button on:click=\"doSomething\">click me</button> <div on=\"doSomething\" get=\"/data\" ></div> <input on=\"doSomething\" post=\"/toggle\" type=\"checkbox\" name=\"agree\" >","title":"Example"},{"location":"special/","text":"Special Actions There a few action names that have a special meaning: reset - if used on a form, will reset said form pushState - will call the same method of the history api, changing the browser URI to the one provided by the redirect attribute, or of it is absent - to the same URI that a request would have been sent by this element replaceState - will call the same method of the history api, changing the browser URI to the one provided by the redirect attribute, or of it is absent - to the same URI that a request would have been sent by this element follow - following the same logic of pushState and replaceState is also going to perform a redirect, but without using the history api and instead going to trigger a full page reload KEML makes the server aware of the AJAX nature of its requests by automatically including a special \"X-Requested-With\" header in each request. KEML makes the server aware of the browsers timezone for the server-side date formatting by setting a \"tzo\" cookie to the value produced by the getTimezoneOffset function. Form Reset Example the form will be automatically reset after a submit (please do note that actions are initiated sequentially from left to right; so if the action list was in the reverse order i.e \"reset handleSubmit\", the form would be reset before submit, making it invalid because the input is required, triggering no actual server request) <form on:submit=\"handLeSubmit reset\" on=\"handLeSubmit\" method=\"post\" action=\"/server-path\" > <input type=\"text\" name=\"name\" required> <button>Submit</button> </form> Redirect Example redirect to \"/\" using the history api after a successful submission of the form <form on:submit=\"handLeSubmit\" on:result=\"pushState\" on=\"handLeSubmit\" method=\"post\" action=\"/login\" redirect=\"/\" > <input type=\"text\" name=\"username\"> <input type=\"password\" name=\"password\"> <button>Login</button> </form> just a normal link, but supercharged by the history api <a on:click=\"replaceState\" href=\"/about\">About</a> Both of the above examples are going to trigger a navigate event. Navigate Event Example send a GET request to \"content\" when a navigate event is triggered and replace all of the children of the div with the server response <div on:navigate=\"loadContent\" on=\"loadContent\" get=\"content\" result=\"pageContent\" render=\"pageContent\" ></div>","title":"Special"},{"location":"special/#special-actions","text":"There a few action names that have a special meaning: reset - if used on a form, will reset said form pushState - will call the same method of the history api, changing the browser URI to the one provided by the redirect attribute, or of it is absent - to the same URI that a request would have been sent by this element replaceState - will call the same method of the history api, changing the browser URI to the one provided by the redirect attribute, or of it is absent - to the same URI that a request would have been sent by this element follow - following the same logic of pushState and replaceState is also going to perform a redirect, but without using the history api and instead going to trigger a full page reload KEML makes the server aware of the AJAX nature of its requests by automatically including a special \"X-Requested-With\" header in each request. KEML makes the server aware of the browsers timezone for the server-side date formatting by setting a \"tzo\" cookie to the value produced by the getTimezoneOffset function.","title":"Special Actions"},{"location":"special/#form-reset-example","text":"the form will be automatically reset after a submit (please do note that actions are initiated sequentially from left to right; so if the action list was in the reverse order i.e \"reset handleSubmit\", the form would be reset before submit, making it invalid because the input is required, triggering no actual server request) <form on:submit=\"handLeSubmit reset\" on=\"handLeSubmit\" method=\"post\" action=\"/server-path\" > <input type=\"text\" name=\"name\" required> <button>Submit</button> </form>","title":"Form Reset Example"},{"location":"special/#redirect-example","text":"redirect to \"/\" using the history api after a successful submission of the form <form on:submit=\"handLeSubmit\" on:result=\"pushState\" on=\"handLeSubmit\" method=\"post\" action=\"/login\" redirect=\"/\" > <input type=\"text\" name=\"username\"> <input type=\"password\" name=\"password\"> <button>Login</button> </form> just a normal link, but supercharged by the history api <a on:click=\"replaceState\" href=\"/about\">About</a> Both of the above examples are going to trigger a navigate event.","title":"Redirect Example"},{"location":"special/#navigate-event-example","text":"send a GET request to \"content\" when a navigate event is triggered and replace all of the children of the div with the server response <div on:navigate=\"loadContent\" on=\"loadContent\" get=\"content\" result=\"pageContent\" render=\"pageContent\" ></div>","title":"Navigate Event Example"},{"location":"state/","text":"State actions HTML elements can configure any number of attributes in response to state actions by prepending their names with x- . Multiple elements can handle the same action and configure their attributes differently. Attributes if:loading specified on an element that launches a request, contains a space separated list of state actions to turn ON immediately before starting a request and to turn OFF immediately after a request completes if:error specified on an element that launches a request, contains a space separated list of state actions to turn OFF immediately before starting a request and to turn ON immediately after a request fails if:invalid specified on a form or a form field, contains a space separated list of state actions to turn ON when the element becomes invalid and to turn OFF when the element becomes valid (invalid forms and fields do not trigger server requests) if specified on any element, including the same one that launched the request, and subscribes to a single state action Loading State Example the first div is initially visible and the second div is initially hidden clicking the button initiates the loadData action turns ON the isLoadingData state action, thus the first div becomes invisible and the second visible sends a \"GET\" request to \"/data\" after completion of the request turns OFF the isLoadingData state action, thus the first div becomes visible and the second invisible again <button on:click=\"loadData\" on=\"loadData\" get=\"/data\" if:loading=\"isLoadingData\" > click me </button> <div if=\"isLoadingData\" x-style=\"display: none\" > not loading </div> <div if=\"isLoadingData\" style=\"display: none\" x-style > loading </div> Error State Example the first div is initially visible and the second div is initially hidden clicking the button initiates the loadWrong action turns OFF the isError state action, which does not change the visibility of the divs sends a \"GET\" request to \"/non-existent\" after completion of the request turns ON the isError state action, because the request has failed, thus the first div becomes invisible and the second visible <button on:click=\"loadWrong\" on=\"loadWrong\" get=\"/non-existent\" if:error=\"isError\" > click me </button> <div if=\"isError\" x-style=\"display: none\" > no error </div> <div if=\"isError\" style=\"display: none\" x-style > error </div> Invalid State Example the first div will be visible initially as well as when the inputs' value becomes a valid email the second div will be visible only when the inputs' value becomes an invalid email <input if:invalid=\"invalidEmail\" type=\"email\" > <div if=\"invalidEmail\" x-style=\"display: none\" > valid </div> <div if=\"invalidEmail\" style=\"display: none\" x-style > invalid </div>","title":"State"},{"location":"state/#state-actions","text":"HTML elements can configure any number of attributes in response to state actions by prepending their names with x- . Multiple elements can handle the same action and configure their attributes differently.","title":"State actions"},{"location":"state/#attributes","text":"if:loading specified on an element that launches a request, contains a space separated list of state actions to turn ON immediately before starting a request and to turn OFF immediately after a request completes if:error specified on an element that launches a request, contains a space separated list of state actions to turn OFF immediately before starting a request and to turn ON immediately after a request fails if:invalid specified on a form or a form field, contains a space separated list of state actions to turn ON when the element becomes invalid and to turn OFF when the element becomes valid (invalid forms and fields do not trigger server requests) if specified on any element, including the same one that launched the request, and subscribes to a single state action","title":"Attributes"},{"location":"state/#loading-state-example","text":"the first div is initially visible and the second div is initially hidden clicking the button initiates the loadData action turns ON the isLoadingData state action, thus the first div becomes invisible and the second visible sends a \"GET\" request to \"/data\" after completion of the request turns OFF the isLoadingData state action, thus the first div becomes visible and the second invisible again <button on:click=\"loadData\" on=\"loadData\" get=\"/data\" if:loading=\"isLoadingData\" > click me </button> <div if=\"isLoadingData\" x-style=\"display: none\" > not loading </div> <div if=\"isLoadingData\" style=\"display: none\" x-style > loading </div>","title":"Loading State Example"},{"location":"state/#error-state-example","text":"the first div is initially visible and the second div is initially hidden clicking the button initiates the loadWrong action turns OFF the isError state action, which does not change the visibility of the divs sends a \"GET\" request to \"/non-existent\" after completion of the request turns ON the isError state action, because the request has failed, thus the first div becomes invisible and the second visible <button on:click=\"loadWrong\" on=\"loadWrong\" get=\"/non-existent\" if:error=\"isError\" > click me </button> <div if=\"isError\" x-style=\"display: none\" > no error </div> <div if=\"isError\" style=\"display: none\" x-style > error </div>","title":"Error State Example"},{"location":"state/#invalid-state-example","text":"the first div will be visible initially as well as when the inputs' value becomes a valid email the second div will be visible only when the inputs' value becomes an invalid email <input if:invalid=\"invalidEmail\" type=\"email\" > <div if=\"invalidEmail\" x-style=\"display: none\" > valid </div> <div if=\"invalidEmail\" style=\"display: none\" x-style > invalid </div>","title":"Invalid State Example"}]}